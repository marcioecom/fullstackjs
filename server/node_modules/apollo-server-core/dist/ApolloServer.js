"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isImplicitlyInstallablePlugin = exports.ApolloServerBase = void 0;
const mock_1 = require("@graphql-tools/mock");
const schema_1 = require("@graphql-tools/schema");
const loglevel_1 = __importDefault(require("loglevel"));
const graphql_1 = require("graphql");
const resolvable_1 = __importDefault(require("@josephg/resolvable"));
const apollo_server_caching_1 = require("apollo-server-caching");
const schemaHash_1 = require("./utils/schemaHash");
const requestPipeline_1 = require("./requestPipeline");
const apollo_server_env_1 = require("apollo-server-env");
const apollo_tools_1 = require("@apollographql/apollo-tools");
const runHttpQuery_1 = require("./runHttpQuery");
const isNodeLike_1 = __importDefault(require("./utils/isNodeLike"));
const determineApolloConfig_1 = require("./determineApolloConfig");
const plugin_1 = require("./plugin");
const internalPlugin_1 = require("./internalPlugin");
const cachePolicy_1 = require("./cachePolicy");
const NoIntrospection = (context) => ({
    Field(node) {
        if (node.name.value === '__schema' || node.name.value === '__type') {
            context.reportError(new graphql_1.GraphQLError('GraphQL introspection is not allowed by Apollo Server, but the query contained __schema or __type. To enable introspection, pass introspection: true to ApolloServer in production', [node]));
        }
    },
});
function approximateObjectSize(obj) {
    return Buffer.byteLength(JSON.stringify(obj), 'utf8');
}
class UnreachableCaseError extends Error {
    constructor(val) {
        super(`Unreachable case: ${val}`);
    }
}
class ApolloServerBase {
    constructor(config) {
        this.graphqlPath = '/graphql';
        this.requestOptions = Object.create(null);
        this.plugins = [];
        this.toDispose = new Set();
        this.toDisposeLast = new Set();
        this.landingPage = null;
        if (!config)
            throw new Error('ApolloServer requires options.');
        this.config = config;
        const { context, resolvers, schema, modules, typeDefs, parseOptions = {}, introspection, mocks, mockEntireSchema, plugins, gateway, experimental_approximateDocumentStoreMiB, stopOnTerminationSignals, apollo, ...requestOptions } = config;
        if (config.logger) {
            this.logger = config.logger;
        }
        else {
            const loglevelLogger = loglevel_1.default.getLogger('apollo-server');
            if (this.config.debug === true) {
                loglevelLogger.setLevel(loglevel_1.default.levels.DEBUG);
            }
            else {
                loglevelLogger.setLevel(loglevel_1.default.levels.INFO);
            }
            this.logger = loglevelLogger;
        }
        this.apolloConfig = determineApolloConfig_1.determineApolloConfig(apollo);
        if (gateway && (modules || schema || typeDefs || resolvers)) {
            throw new Error('Cannot define both `gateway` and any of: `modules`, `schema`, `typeDefs`, or `resolvers`');
        }
        this.parseOptions = parseOptions;
        this.context = context;
        const nodeEnv = '__testing_nodeEnv__' in config
            ? config.__testing_nodeEnv__
            : process.env.NODE_ENV;
        const isDev = nodeEnv !== 'production';
        if ((typeof introspection === 'boolean' && !introspection) ||
            (introspection === undefined && !isDev)) {
            const noIntro = [NoIntrospection];
            requestOptions.validationRules = requestOptions.validationRules
                ? requestOptions.validationRules.concat(noIntro)
                : noIntro;
        }
        if (!requestOptions.cache) {
            requestOptions.cache = new apollo_server_caching_1.InMemoryLRUCache();
        }
        if (requestOptions.persistedQueries !== false) {
            const { cache: apqCache = requestOptions.cache, ...apqOtherOptions } = requestOptions.persistedQueries || Object.create(null);
            requestOptions.persistedQueries = {
                cache: new apollo_server_caching_1.PrefixingKeyValueCache(apqCache, requestPipeline_1.APQ_CACHE_PREFIX),
                ...apqOtherOptions,
            };
        }
        else {
            delete requestOptions.persistedQueries;
        }
        this.requestOptions = requestOptions;
        this.ensurePluginInstantiation(plugins, isDev);
        if (typeof stopOnTerminationSignals === 'boolean'
            ? stopOnTerminationSignals
            : isNodeLike_1.default && nodeEnv !== 'test') {
            const signals = ['SIGINT', 'SIGTERM'];
            let receivedSignal = false;
            signals.forEach((signal) => {
                const handler = async () => {
                    if (receivedSignal) {
                        return;
                    }
                    receivedSignal = true;
                    try {
                        await this.stop();
                    }
                    catch (e) {
                        this.logger.error(`stop() threw during ${signal} shutdown`);
                        this.logger.error(e);
                        process.exit(1);
                    }
                    process.kill(process.pid, signal);
                };
                process.on(signal, handler);
                this.toDisposeLast.add(async () => {
                    process.removeListener(signal, handler);
                });
            });
        }
        if (gateway) {
            this.state = { phase: 'initialized with gateway', gateway };
            this.requestOptions.executor = gateway.executor;
        }
        else {
            this.state = {
                phase: 'initialized with schema',
                schemaDerivedData: this.generateSchemaDerivedData(this.maybeAddMocksToConstructedSchema(this.constructSchema())),
            };
        }
        if (this.serverlessFramework()) {
            this._start().catch((e) => this.logStartupError(e));
        }
    }
    async start() {
        if (this.serverlessFramework()) {
            throw new Error('When using an ApolloServer subclass from a serverless framework ' +
                "package, you don't need to call start(); just call createHandler().");
        }
        return await this._start();
    }
    async _start() {
        var _a;
        const initialState = this.state;
        if (initialState.phase !== 'initialized with gateway' &&
            initialState.phase !== 'initialized with schema') {
            throw new Error(`called start() with surprising state ${initialState.phase}`);
        }
        const barrier = resolvable_1.default();
        this.state = { phase: 'starting', barrier };
        let loadedSchema = false;
        try {
            const schemaDerivedData = initialState.phase === 'initialized with schema'
                ? initialState.schemaDerivedData
                : this.generateSchemaDerivedData(await this.startGatewayAndLoadSchema(initialState.gateway));
            loadedSchema = true;
            this.state = {
                phase: 'invoking serverWillStart',
                barrier,
                schemaDerivedData,
            };
            const service = {
                logger: this.logger,
                schema: schemaDerivedData.schema,
                schemaHash: schemaDerivedData.schemaHash,
                apollo: this.apolloConfig,
                serverlessFramework: this.serverlessFramework(),
            };
            if ((_a = this.requestOptions.persistedQueries) === null || _a === void 0 ? void 0 : _a.cache) {
                service.persistedQueries = {
                    cache: this.requestOptions.persistedQueries.cache,
                };
            }
            const taggedServerListeners = (await Promise.all(this.plugins.map(async (plugin) => ({
                serverListener: plugin.serverWillStart && (await plugin.serverWillStart(service)),
                installedImplicity: isImplicitlyInstallablePlugin(plugin) &&
                    plugin.__internal_installed_implicitly__,
            })))).filter((maybeTaggedServerListener) => typeof maybeTaggedServerListener.serverListener === 'object');
            const serverWillStops = taggedServerListeners.flatMap((l) => l.serverListener.serverWillStop
                ? [l.serverListener.serverWillStop]
                : []);
            if (serverWillStops.length) {
                this.toDispose.add(async () => {
                    await Promise.all(serverWillStops.map((serverWillStop) => serverWillStop()));
                });
            }
            let taggedServerListenersWithRenderLandingPage = taggedServerListeners.filter((l) => l.serverListener.renderLandingPage);
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                taggedServerListenersWithRenderLandingPage =
                    taggedServerListenersWithRenderLandingPage.filter((l) => !l.installedImplicity);
            }
            if (taggedServerListenersWithRenderLandingPage.length > 1) {
                throw Error('Only one plugin can implement renderLandingPage.');
            }
            else if (taggedServerListenersWithRenderLandingPage.length) {
                this.landingPage = await taggedServerListenersWithRenderLandingPage[0]
                    .serverListener.renderLandingPage();
            }
            else {
                this.landingPage = null;
            }
            this.state = { phase: 'started', schemaDerivedData };
        }
        catch (error) {
            this.state = { phase: 'failed to start', error, loadedSchema };
            throw error;
        }
        finally {
            barrier.resolve();
        }
    }
    async _ensureStarted() {
        while (true) {
            switch (this.state.phase) {
                case 'initialized with gateway':
                case 'initialized with schema':
                    throw new Error('You need to call `server.start()` before using your Apollo Server.');
                case 'starting':
                case 'invoking serverWillStart':
                    await this.state.barrier;
                    break;
                case 'failed to start':
                    this.logStartupError(this.state.error);
                    throw new Error('This data graph is missing a valid configuration. More details may be available in the server logs.');
                case 'started':
                    return this.state.schemaDerivedData;
                case 'stopping':
                    throw new Error('Cannot execute GraphQL operations while the server is stopping.');
                case 'stopped':
                    throw new Error('Cannot execute GraphQL operations after the server has stopped.');
                default:
                    throw new UnreachableCaseError(this.state);
            }
        }
    }
    async ensureStarted() {
        await this._ensureStarted();
    }
    assertStarted(methodName) {
        if (this.state.phase !== 'started') {
            throw new Error('You must `await server.start()` before calling `server.' +
                methodName +
                '()`');
        }
    }
    logStartupError(err) {
        this.logger.error('An error occurred during Apollo Server startup. All GraphQL requests ' +
            'will now fail. The startup error was: ' +
            ((err && err.message) || err));
    }
    async startGatewayAndLoadSchema(gateway) {
        const unsubscriber = gateway.onSchemaChange((schema) => {
            if (this.state.phase === 'started') {
                this.state.schemaDerivedData = this.generateSchemaDerivedData(schema);
            }
        });
        this.toDispose.add(async () => unsubscriber());
        const config = await gateway.load({
            apollo: this.apolloConfig,
        });
        this.toDispose.add(async () => { var _a; return await ((_a = gateway.stop) === null || _a === void 0 ? void 0 : _a.call(gateway)); });
        return config.schema;
    }
    constructSchema() {
        const { schema, modules, typeDefs, resolvers, parseOptions } = this.config;
        if (schema) {
            return schema;
        }
        if (modules) {
            const { schema, errors } = apollo_tools_1.buildServiceDefinition(modules);
            if (errors && errors.length > 0) {
                throw new Error(errors.map((error) => error.message).join('\n\n'));
            }
            return schema;
        }
        if (!typeDefs) {
            throw Error('Apollo Server requires either an existing schema, modules or typeDefs');
        }
        const augmentedTypeDefs = Array.isArray(typeDefs) ? typeDefs : [typeDefs];
        return schema_1.makeExecutableSchema({
            typeDefs: augmentedTypeDefs,
            resolvers,
            parseOptions,
        });
    }
    maybeAddMocksToConstructedSchema(schema) {
        const { mocks, mockEntireSchema } = this.config;
        if (mocks === false) {
            return schema;
        }
        if (!mocks && typeof mockEntireSchema === 'undefined') {
            return schema;
        }
        return mock_1.addMocksToSchema({
            schema,
            mocks: mocks === true || typeof mocks === 'undefined' ? {} : mocks,
            preserveResolvers: typeof mockEntireSchema === 'undefined' ? false : !mockEntireSchema,
        });
    }
    generateSchemaDerivedData(schema) {
        const schemaHash = schemaHash_1.generateSchemaHash(schema);
        const documentStore = this.initializeDocumentStore();
        return {
            schema,
            schemaHash,
            documentStore,
        };
    }
    async stop() {
        if (this.state.phase === 'stopped') {
            if (this.state.stopError) {
                throw this.state.stopError;
            }
            return;
        }
        if (this.state.phase === 'stopping') {
            await this.state.barrier;
            const state = this.state;
            if (state.phase !== 'stopped') {
                throw Error(`Surprising post-stopping state ${state.phase}`);
            }
            if (state.stopError) {
                throw state.stopError;
            }
            return;
        }
        this.state = { phase: 'stopping', barrier: resolvable_1.default() };
        try {
            await Promise.all([...this.toDispose].map((dispose) => dispose()));
            await Promise.all([...this.toDisposeLast].map((dispose) => dispose()));
        }
        catch (stopError) {
            this.state = { phase: 'stopped', stopError };
            return;
        }
        this.state = { phase: 'stopped', stopError: null };
    }
    serverlessFramework() {
        return false;
    }
    ensurePluginInstantiation(userPlugins = [], isDev) {
        this.plugins = userPlugins.map((plugin) => {
            if (typeof plugin === 'function') {
                return plugin();
            }
            return plugin;
        });
        const alreadyHavePluginWithInternalId = (id) => this.plugins.some((p) => internalPlugin_1.pluginIsInternal(p) && p.__internal_plugin_id__() === id);
        {
            if (!alreadyHavePluginWithInternalId('CacheControl')) {
                this.plugins.push(plugin_1.ApolloServerPluginCacheControl());
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('UsageReporting');
            if (!alreadyHavePlugin && this.apolloConfig.key) {
                if (this.apolloConfig.graphRef) {
                    this.plugins.unshift(plugin_1.ApolloServerPluginUsageReporting());
                }
                else {
                    this.logger.warn('You have specified an Apollo key but have not specified a graph ref; usage ' +
                        'reporting is disabled. To enable usage reporting, set the `APOLLO_GRAPH_REF` ' +
                        'environment variable to `your-graph-id@your-graph-variant`. To disable this ' +
                        'warning, install `ApolloServerPluginUsageReportingDisabled`.');
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('SchemaReporting');
            const enabledViaEnvVar = process.env.APOLLO_SCHEMA_REPORTING === 'true';
            if (alreadyHavePlugin || enabledViaEnvVar) {
                if (this.config.gateway) {
                    throw new Error([
                        "Schema reporting is not yet compatible with the gateway. If you're",
                        'interested in using schema reporting with the gateway, please',
                        'contact Apollo support. To set up managed federation, see',
                        'https://go.apollo.dev/s/managed-federation',
                    ].join(' '));
                }
            }
            if (!alreadyHavePlugin) {
                if (!this.apolloConfig.key) {
                    if (enabledViaEnvVar) {
                        throw new Error("You've enabled schema reporting by setting the APOLLO_SCHEMA_REPORTING " +
                            'environment variable to true, but you also need to provide your ' +
                            'Apollo API key, via the APOLLO_KEY environment ' +
                            'variable or via `new ApolloServer({apollo: {key})');
                    }
                }
                else if (enabledViaEnvVar) {
                    const options = {};
                    this.plugins.push(plugin_1.ApolloServerPluginSchemaReporting(options));
                }
            }
        }
        {
            const alreadyHavePlugin = alreadyHavePluginWithInternalId('InlineTrace');
            if (!alreadyHavePlugin) {
                this.plugins.push(plugin_1.ApolloServerPluginInlineTrace({ __onlyIfSchemaIsFederated: true }));
            }
        }
        const alreadyHavePlugin = alreadyHavePluginWithInternalId('LandingPageDisabled');
        if (!alreadyHavePlugin) {
            const plugin = isDev
                ? plugin_1.ApolloServerPluginLandingPageLocalDefault()
                : plugin_1.ApolloServerPluginLandingPageProductionDefault();
            if (!isImplicitlyInstallablePlugin(plugin)) {
                throw Error('default landing page plugin should be implicitly installable?');
            }
            plugin.__internal_installed_implicitly__ = true;
            this.plugins.push(plugin);
        }
    }
    initializeDocumentStore() {
        return new apollo_server_caching_1.InMemoryLRUCache({
            maxSize: Math.pow(2, 20) * (this.experimental_approximateDocumentStoreMiB || 30),
            sizeCalculator: approximateObjectSize,
        });
    }
    async graphQLServerOptions(integrationContextArgument) {
        const { schema, schemaHash, documentStore } = await this._ensureStarted();
        let context = this.context ? this.context : {};
        try {
            context =
                typeof this.context === 'function'
                    ? await this.context(integrationContextArgument || {})
                    : context;
        }
        catch (error) {
            context = () => {
                throw error;
            };
        }
        return {
            schema,
            schemaHash,
            logger: this.logger,
            plugins: this.plugins,
            documentStore,
            context,
            parseOptions: this.parseOptions,
            ...this.requestOptions,
        };
    }
    async executeOperation(request, integrationContextArgument) {
        if (this.state.phase === 'initialized with gateway' ||
            this.state.phase === 'initialized with schema') {
            await this._start();
        }
        const options = await this.graphQLServerOptions(integrationContextArgument);
        if (typeof options.context === 'function') {
            options.context = options.context();
        }
        else if (typeof options.context === 'object') {
            options.context = runHttpQuery_1.cloneObject(options.context);
        }
        const requestCtx = {
            logger: this.logger,
            schema: options.schema,
            schemaHash: options.schemaHash,
            request: {
                ...request,
                query: request.query && typeof request.query !== 'string'
                    ? graphql_1.print(request.query)
                    : request.query,
            },
            context: options.context || Object.create(null),
            cache: options.cache,
            metrics: {},
            response: {
                http: {
                    headers: new apollo_server_env_1.Headers(),
                },
            },
            debug: options.debug,
            overallCachePolicy: cachePolicy_1.newCachePolicy(),
        };
        return requestPipeline_1.processGraphQLRequest(options, requestCtx);
    }
    getLandingPage() {
        this.assertStarted('getLandingPage');
        return this.landingPage;
    }
}
exports.ApolloServerBase = ApolloServerBase;
function isImplicitlyInstallablePlugin(p) {
    return '__internal_installed_implicitly__' in p;
}
exports.isImplicitlyInstallablePlugin = isImplicitlyInstallablePlugin;
//# sourceMappingURL=ApolloServer.js.map